#pragma comment(lib, "Ws2_32.lib")
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include <fstream>




































































































































































































































































































































































































































































































































































































































































































































































































































































































#include <iostream>
#include <opencv2\core\core.hpp>
#include <opencv2\highgui\highgui.hpp>
#include <opencv2\video\background_segm.hpp>
#include <opencv2\opencv.hpp>
#include <string>
#include <stdlib.h>
#include <stdio.h>
#include <vector>
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <Windows.h>



using namespace cv;
using namespace std;

int location[4];//Array to store X, Y values for both players.
bool shooting = false;
bool editing = true;//editing is diabled per default.
bool debugging = false;//Disables debugging per default to allow users to see the help screen at first upstart.

//Allocating memory for min and max values for the thresholding
int
H_MIN1, H_MAX1, S_MIN1, S_MAX1, V_MIN1, V_MAX1, 
H_MIN2, H_MAX2, S_MIN2, S_MAX2, V_MIN2, V_MAX2,
shootingThreshold;
int releaseCoefficient = 0;

int prevArea = 20000;
int currentArea;

Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
BackgroundSubtractorMOG MOG;

//This function just prints some helping commands to the console. Only called when the user is not "debugging".
void help()
{
	cout
		<< "This program's functions is to perform the calibrations of the webcam used for \n"
		<< "the unity3D game and then track the objects in the frame and broadcast the co-\n"
		<< "ordinates to unity.\n\n"
		<< "The sliders are used to find the relevant HSV values for each controller type\n"
		<< "used in thresholding the colors.\n"
		<< "\n\n\n\n\n"
		<< "The program uses the following hotkeys: \n"
		<< "______________________________________________________________________\n\n"
		<< "  Press [E]diting to change between editing or broadcasting.\n\n"
		<< "  Press [D]ebug to change between the debug log or input-help message.\n\n"
		<< "  Press [S]ave to save configurations on your harddisk.\n\n"
		<< "  Press [Esc]ape to terminate the program.\n"
		<< "______________________________________________________________________\n\n"
		<< "Program state: You are ";
		if (editing)
			cout << "editing\n";
		else
			cout << "broadcasting\n";
}

/*
Creation and destruction of trackbar windows is handled upon keyinput in the while loop,
so it is not called each loop cycle, that would result in problem with creating the windows.
*/
void EditingTrackbar()
{
	cv::destroyWindow("Editor");//Clears up old window
	namedWindow("Editor");
	resizeWindow("Editor", 290, 600);

	createTrackbar("A Hue-MIN", "Editor", &H_MIN2, 255); createTrackbar("A Hue-MAX", "Editor", &H_MAX2, 255);
	createTrackbar("A Sat-MIN", "Editor", &S_MIN2, 255); createTrackbar("A Sat-MAX", "Editor", &S_MAX2, 255);
	createTrackbar("A Val-MIN", "Editor", &V_MIN2, 255); createTrackbar("A Val-MAX", "Editor", &V_MAX2, 255);
	createTrackbar("P Hue-MIN", "Editor", &H_MIN1, 255); createTrackbar("P Hue-MAX", "Editor", &H_MAX1, 255);
	createTrackbar("P Sat-MIN", "Editor", &S_MIN1, 255); createTrackbar("P Sat-MAX", "Editor", &S_MAX1, 255);
	createTrackbar("P Val-MIN", "Editor", &V_MIN1, 255); createTrackbar("P Val-MAX", "Editor", &V_MAX1, 255);
	createTrackbar("Obj Size", "Editor", &shootingThreshold, 10000);
}

//Saving configuration to a txt file
void writeConfigurations()
{
	//Create a ofstream (output file stream) class that can handle the output from the program, to the text file.
	ofstream calibrationFile;
	//Open/create the relevant file, depending on which string variable(name of file) was in the command
	//fstream::trunc makes sure the file is empty before writing the values further down the code.
	calibrationFile.open("OpenCVConfiguration.txt", fstream::out | fstream::trunc);
	//If for some reason the file failed to open, function will print an error message.
	if (!calibrationFile)
		cout << "Failed to open relevant calibration file." << endl;
	//The config for the power controller needs a different set of values that are in the HSV colorspace.
	//So in this case, the HSV values are written instead of BGR.
	else{
		calibrationFile
			<< "H_MIN1 = \n" << H_MIN1 << endl
			<< "H_MAX1 = \n" << H_MAX1 << endl
			<< "S_MIN1 = \n" << S_MIN1 << endl
			<< "S_MAX1 = \n" << S_MAX1 << endl
			<< "V_MIN1 = \n" << V_MIN1 << endl
			<< "V_MAX1 = \n" << V_MAX1 << endl
			<< "H_MIN2 = \n" << H_MIN2 << endl
			<< "H_MAX2 = \n" << H_MAX2 << endl
			<< "S_MIN2 = \n" << S_MIN2 << endl
			<< "S_MAX2 = \n" << S_MAX2 << endl
			<< "V_MIN2 = \n" << V_MIN2 << endl
			<< "V_MAX2 = \n" << V_MAX2 << endl
			<< "Size = \n" << shootingThreshold << endl;

		//Ensures that the file is properly closed once the program is done writing.
		calibrationFile.close();
	}
}

//Loading configuration 
void loadConfig()
{
	ifstream calibrationFile;
	int lineCount = 0;
	calibrationFile.open("OpenCVConfiguration.txt");

	/*
	From the writeConfigurations() function we know that every other line from the text file
	is the value that we want to convert to an int,	and save into variables.
	Line numbers start as 0 ascend.
	So line 1 = H_MIN1, line 3 = H_MAX1, line 5 = S_MIN1, line 7 = S_MAX1 etc.
	*/

	if (calibrationFile)
	{
		string line;
		string textFile[26];

		while (getline(calibrationFile, line))
		{
			textFile[lineCount] = line;
			lineCount++;
		}

		H_MIN1 = stoi(textFile[1]);  H_MAX1 = stoi(textFile[3]);
		S_MIN1 = stoi(textFile[5]);	 S_MAX1 = stoi(textFile[7]);
		V_MIN1 = stoi(textFile[9]);	 V_MAX1 = stoi(textFile[11]);
		H_MIN2 = stoi(textFile[13]); H_MAX2 = stoi(textFile[15]);
		S_MIN2 = stoi(textFile[17]); S_MAX2 = stoi(textFile[19]);
		V_MIN2 = stoi(textFile[21]); V_MAX2 = stoi(textFile[23]);
		shootingThreshold = stoi(textFile[25]);
		cout << "Configurations have been loaded." << endl;
	}
	else//Set default values
	{
		H_MIN1 = 0;
		H_MAX1 = 255;
		S_MIN1 = 0;
		S_MAX1 = 255;
		V_MIN1 = 0;
		V_MAX1 = 255;
		H_MIN2 = 0;
		H_MAX2 = 255;
		S_MIN2 = 0;
		S_MAX2 = 255;
		V_MIN2 = 0;
		V_MAX2 = 255;
		shootingThreshold = 500;

		cout << "Configurations are set to default." << endl;
	}
}

Mat backgroundSubtraction(Mat &frame)
{
	Mat dest;

	MOG(frame, fgMaskMOG);
	frame.copyTo(dest, fgMaskMOG);
	//imshow("FG Mask MOG", fgMaskMOG);
	//imshow("test 1", dest);
	return dest;
}

Mat backgroundSubtraction(Mat &frame, bool reset)
{
	Mat dest;
	if (reset)
		MOG(frame, fgMaskMOG, 1.0);
	else
		MOG(frame, fgMaskMOG);
	frame.copyTo(dest, fgMaskMOG);
	//imshow("FG Mask MOG", fgMaskMOG);
	//imshow("test 1", dest);
	return dest;
}

//Used to perform morphological operations on the relevant frame.
void morphOps(Mat &thresh)
{
	//Create the structuring element used in the morphological operations
	Mat erodeElement = getStructuringElement(MORPH_ELLIPSE, Size(3, 3));
	Mat dilateElement = getStructuringElement(MORPH_ELLIPSE, Size(3, 3));
	//Perform the operations
	medianBlur(thresh, thresh, 3);
	erode(thresh, thresh, erodeElement, Point(-1, -1), 2);
	dilate(thresh, thresh, dilateElement, Point(-1, -1), 5);
	//erode(thresh, thresh, erodeElement, Point(-1, -1), 1);
	//dilate(thresh, thresh, erodeElement, Point(-1, -1), 1);
}


vector<int> findCoords(Mat threshold)
{
	vector<int> blobProperties(3);
	//these vectors are needed to save the output of findCountours
	vector< vector<Point> > contours;
	vector<Vec4i> hierarchy;

	//Find the contours of the image
	findContours(threshold, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);

	//Moments are used to find the filtered objects.
	if (!contours.empty() && !hierarchy.empty())
	{
		int numObjects = hierarchy.size();
		//Checks if the filter may be noisy.
		if (numObjects <= 1)
		{
			for (int i = 0; i >= 0; i = hierarchy[i][0])
			{
				Moments moment = moments((Mat)contours[i]);
				double area = moment.m00;
				//This finds objects, if area is lesser than min_area it is probably noise
				if (area > 10)//1728 is the Minimum object area
				{
					blobProperties[0] = (int)(moment.m10 / area);//BLOB X
					blobProperties[1] = (int)(moment.m01 / area);//BLOB Y
					blobProperties[2] = (int)area;//BLOB Area

				}
			}
		}
		else
			blobProperties[2] = -2;//BLOB Area
	}
	else
		blobProperties[2] = -1;//BLOB Area

	return blobProperties;
}

//This function functions calculates the coordinates of the ovjects and if any player is shooting
void trackObjects(Mat powerThreshold, Mat angleThreshold, Mat &cameraFeed)
{
	vector<int> temp = findCoords(angleThreshold);//Temporary data holder

	currentArea = temp[2];
	if (currentArea > 0)
	{
		location[0] = temp[0];//Left angle X
		location[1] = temp[1];//Left angle Y
	}
	else if (debugging)
	{
		if (currentArea == -1)
			cout << "\nNo angle object found!";
		else if (currentArea == -2)
			cout << "\nToo many angle objects found!";
	}

	temp = findCoords(powerThreshold);
	currentArea = temp[2];
	if (currentArea > 0)
	{
		location[2] = temp[0];//Left power X
		location[3] = temp[1];//Left power Y

		if (currentArea > shootingThreshold)//Is the size of his hand bigger than the threshold.
			shooting = true;//The player is shooting!
		else
			shooting = false;	
	}
	else
	{
		shooting = false;//If no objects are found the player will not keep shooting.
		if (debugging)
		{
			if (currentArea == -1)
				cout << "\nNo power object found!";
			else if (currentArea == -2)
				cout << "\nToo many power objects found!";
		}
	}
}

void broadcast()
{
	//These are just notes
	/*
	int location[0] angle X
	int location[1] angle Y
	int location[2] power X
	int location[3] power Y
	bool shooting Shot-state
	*/

	string DataString;
	//Converts int array to one string.
	for (int i = 0; i < 4; i++){
		//Fills zeroes in so each location uses 3 char's of space no matter what.
		if (to_string(location[i]).length() < 3){
			if (to_string(location[i]).length() < 2){
				DataString += "00" + to_string(location[i]);
			}
			else
				DataString += "0" + to_string(location[i]);
		}
		else
			DataString += to_string(location[i]);
	}

	if (shooting)
		DataString += "1";
	else
		DataString += "0";
	
	cout << DataString << endl;

	int iResult;
	WSADATA wsaData;

	SOCKET SendSocket = INVALID_SOCKET;
	sockaddr_in RecvAddr;

	//Buffer with the same length as the string I am sending
	char SendBuf[13];
	int BufLen = 13;

	//Convert from string to char array
	for (int i = 0; i < BufLen; i++)
		SendBuf[i] = DataString[i];

	// Initialize Winsock
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != NO_ERROR) {
		cout << "WSAStartup failed with error: " << iResult << endl;
		return;
	}

	// Create a socket for sending data
	SendSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (SendSocket == INVALID_SOCKET) {
		cout << "socket failed with error: " << WSAGetLastError() << endl;
		WSACleanup();
		return;
	}

	// Set up the RecvAddr structure
	RecvAddr.sin_family = AF_INET;
	RecvAddr.sin_port = htons(11000);//port for the communication
	RecvAddr.sin_addr.s_addr = inet_addr("127.0.0.1");//Addre


	// Send a datagram to the receiver
	iResult = sendto(SendSocket, SendBuf, BufLen, 0, (SOCKADDR *)& RecvAddr, sizeof (RecvAddr));
	if (iResult == SOCKET_ERROR)
	{
		cout << "sendto failed with error: " << WSAGetLastError() << endl;
		closesocket(SendSocket);
		WSACleanup();
		return;
	}

	// When the application is finished sending, close the socket.
	iResult = closesocket(SendSocket);
	if (iResult == SOCKET_ERROR)
	{
		cout << "closesocket failed with error: " << WSAGetLastError() << endl;
		WSACleanup();
		return;
	}

	// Clean up and quit.
	WSACleanup();
}

int main()
{
	BackgroundSubtractorMOG MOG;

	//Create the Mat(image) variables for later.
	Mat cameraFeed, subtracted, HSV, HsvThreshold1, HsvThreshold2;

	//The following 28 lines is camera initialization 
	bool cameraOn;
	VideoCapture capture(0);//Open number one cameraport(probably the the internal one) for recording.
	if (capture.isOpened()) // Check if we succeeded
		cameraOn = true;
	else 
	{
		VideoCapture capture(1);//Open number two cameraport(probably the the internal one) for recording.
		if (capture.isOpened()) //Check if we succeeeeeeded.
			cameraOn = true;
		else//If no camera succeeded.
		{
			cout << "Failed to initialize camera. Trying to load image from the programs location" << endl;
			cameraOn = false;
			cameraFeed = imread("img.png");//Load image from hdd. for testing purpose
			if (cameraFeed.empty())
			{
				cout << "Could not find image";//Error message
				Sleep(4000);//Stops the program so the user can see the error message.
				return 0;//Terminates the program.
			}
			else
				cout << "image from the programs location successfully loaded!" << endl;
		}
	}
	
	//Limits the dimensions of the captured frame
	//capture.set(CV_CAP_PROP_FRAME_WIDTH, 480);
	//capture.set(CV_CAP_PROP_FRAME_HEIGHT, 360);
	
	//Load configurations
	loadConfig();

	//The following is intial setup.
	namedWindow("Original Frame", WINDOW_NORMAL); resizeWindow("Original Frame", 640, 360);
	namedWindow("Subtracted Image", WINDOW_NORMAL); resizeWindow("Subtracted Image", 640, 360);
	namedWindow("Thresholded Power Controllers", WINDOW_NORMAL); resizeWindow("Thresholded Power Controllers", 640, 360);
	namedWindow("Thresholded Angle Controllers", WINDOW_NORMAL); resizeWindow("Thresholded Angle Controllers", 640, 360);
	EditingTrackbar();

	//Call the help function to make sure people know how to work the program.
	help();

	//Almost infinite loop - will run until 'Esc'-key is pressed.
	while (!GetAsyncKeyState(VK_ESCAPE))
	{
		
		if (cameraOn){//If using webcam.
			capture.read(cameraFeed);//Store an frame from the webcam.
			subtracted = backgroundSubtraction(cameraFeed);
		}
		else
			subtracted = cameraFeed;

		//Convert the frame to HSV colorspace		
		cv::cvtColor(subtracted, HSV, CV_BGR2HSV);
		
		//Threshold the image
		inRange(HSV, Scalar(H_MIN1, S_MIN1, V_MIN1), Scalar(H_MAX1, S_MAX1, V_MAX1), HsvThreshold1);
		inRange(HSV, Scalar(H_MIN2, S_MIN2, V_MIN2), Scalar(H_MAX2, S_MAX2, V_MAX2), HsvThreshold2);

		//perform morphological operations
		morphOps(HsvThreshold1);
		morphOps(HsvThreshold2);

		if (!editing || editing && debugging)//If we need the coordinates
			trackObjects(HsvThreshold1, HsvThreshold2, HSV);


		if (editing)
		{
			//Display frame and Thresholded frame
			imshow("Original Frame", cameraFeed);
			imshow("Subtracted Image", subtracted);
			imshow("Thresholded Power Controllers", HsvThreshold1);
			imshow("Thresholded Angle Controllers", HsvThreshold2);
		}
		else//If not editing.
			broadcast();//Converts coordinates and broadcasts the values to Unity3D


		if (debugging)
		{
			//These are just notes
			/*
			int location[0] angle X
			int location[1] angle Y
			int location[2] power X
			int location[3] power Y
			bool shooting Shot-state
			*/

			cout << "\nAngle Controllers: (" << location[0] << "," << location[1] << ")\n"
				<< "Power Controllers: (" << location[2] << "," << location[3] << ")\n"
				<< "Current size: " << currentArea << ". Shooting state: " << shooting << endl;
			for (int i = 0; i <= 3; i += 2)//Draw lines to show where the objects are tracked on the HSV Mat
			{
				//This creates two lines which is 20 pixels long, crossing over (location[i],location[i+1])
				line(HSV, Point(location[i] - 10, location[i + 1]), Point(location[i] + 10, location[i + 1]), cv::Scalar(0, 0, 255), 2);//Horizontal black line
				line(HSV, Point(location[i], location[i + 1] - 10), Point(location[i], location[i + 1] + 10), cv::Scalar(0, 0, 255), 2);//Vertical white line
			}

			if (shooting)
				circle(HSV, Point(location[2], location[3]), 10, cv::Scalar(0, 0, 255), 2, 8);

			imshow("Tracked Image", HSV);//Show the Mat with the tracked objects
		}

		if (editing || debugging)//If we are drawing windows
			waitKey(30);//OpenCV need this delay because we are drawing any windows each run. Otherwise it will not update them.

		if (GetAsyncKeyState(69))//'e' is pressed!
		{
			//toggle between editing boolean.
			if (!editing)
			{
				namedWindow("Original Frame", WINDOW_NORMAL); resizeWindow("Original Frame", 640, 360);
				namedWindow("Subtracted Image", WINDOW_NORMAL); resizeWindow("Subtracted Image", 640, 360);
				namedWindow("Thresholded Power Controllers", WINDOW_NORMAL); resizeWindow("Thresholded Power Controllers", 640, 360);
				namedWindow("Thresholded Angle Controllers", WINDOW_NORMAL); resizeWindow("Thresholded Angle Controllers", 640, 360);
				EditingTrackbar(); 

				editing = true;
				help();
			}
			else{
				destroyWindow("Original Frame");
				destroyWindow("Subtracted Image");
				destroyWindow("Thresholded Power Controllers");
				destroyWindow("Thresholded Angle Controllers");
				destroyWindow("Editor");

				editing = false;
				help();
			}
		}

		if (GetAsyncKeyState(68))//'d' is pressed!
		{
			if (debugging)
			{
				help();//Display help, else display debug log
				destroyWindow("Tracked Image");
			}
			else
				namedWindow("Tracked Image", WINDOW_NORMAL); resizeWindow("Tracked Image", 640, 360);

			debugging = !debugging;
		}

		if (GetAsyncKeyState(82))//'r' is pressed!
			backgroundSubtraction(cameraFeed, true);

		if (GetAsyncKeyState(83))//'s' is pressed!
		{
			writeConfigurations();//Save configurations
			cout << "Configurations have been saved" << endl;
		}
	}
}
